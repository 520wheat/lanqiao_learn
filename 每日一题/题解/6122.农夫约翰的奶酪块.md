# 6122.农夫约翰的奶酪块

农夫约翰有一块立方体形状的奶酪，它位于三维坐标空间中，从 (0,0,0) 延伸至 (N,N,N) 。
农夫约翰将对他的奶酪块执行一系列 Q 次更新操作。
对于每次更新操作，农夫约翰将从整数坐标 (x,y,z) 到 (x+1,y+1,z+1) 处
切割出一个 1×1×1 的奶酪块，其中 0≤x,y,z<N。

输入保证在农夫约翰切割的位置上存在一个 1×1×1 的奶酪块。

由于农夫约翰正在玩牛的世界，当下方的奶酪被切割后，重力不会导致上方的奶酪掉落。
在每次更新后，输出农夫约翰可以将一个 1×1×N 的砖块插入奶酪块中的方案数，
使得砖块的任何部分都不与剩余的奶酪重叠。
砖块的每个顶点在全部三个坐标轴上均必须具有整数坐标，范围为 [0,N]。

农夫约翰可以随意旋转砖块。

## 输入格式

输入的第一行包含 N 和 Q。

以下 Q 行包含 x，y 和 z，为要切割的位置的坐标。

## 输出格式

在每次更新操作后，输出一个整数，为所求的方案数。

## 数据范围

2≤N≤1000,
1≤Q≤2×105,
0≤x,y,z<N

### 输入样例：

2 5
0 0 0
1 1 1
0 1 0
1 0 0
1 1 0

### 输出样例：

0
0
1
2
5

### 样例解释

在前三次更新操作后，[0,1]×[0,2]×[0,1] 范围的 1×2×1 砖块与剩余的奶酪不重叠，因此它贡献了答案。

------

以上是原题，我是觉得**不太像人话，翻译一下**就是：
奶酪是边长为 N 的立方体，可以挖 q 次，
每次输入一个三维坐标，表示从 (a,b,c) 挖到 (a+1,b+1,c+1)
问挖完之后能有几个方式放一根 1x1xN 的砖

------

## AC代码

暴力O(n)

```cpp
#include<iostream>
using namespace std;
#define read(x) scanf("%d",&x)

const int N = 1010;
int n,q;
int x,y,z;
int ans = 0;
int a[N][N],b[N][N],c[N][N];

int main(){
    read(n);read(q);
    while(q--){
        read(x);read(y);read(z);
        a[x][y]++;
        b[x][z]++;
        c[y][z]++;

        // if(a[x][y]==n || b[x][z]==n || c[y][z]==n)  ans++;
        if(a[x][y]==n)  ans++;
        if(b[x][z]==n)  ans++;
        if(c[y][z]==n)  ans++;

        printf("%d\n",ans);
    }
    return 0;
}
```

一开始确实是没有思路，只能是仰仗题解区的大佬了，
由数据量可以知道不能使用三维数组（会超时，也会爆）
所以使用了**三个二维数组**
数组**a**表示xy平面，数组**b**表示xz平面，数组**c**表示yz平面

由于这三个平面都没有第三个维度参与，所以可以用来表示坐标面，
在三维空间上的某个方块进行挖掘可以视为在三个坐标面上的**对应映射点**上进行挖掘，
这样的好处是不需要在意他在这个点所延长的法线的哪里进行挖掘，因为都会投影到坐标面上的点。

这样可能还是不太好理解，我们可以举个栗子：

> 1.样例中第一个挖掘的点是（0,0,0），那就是从（0,0,0）挖到（1,1,1）
> 2.在我们的设想里是，我们在三个坐标面上找到对应的投影点
> （a平面上的（0,0），b品面上的（0,0），c平面上的（0,0）），
> 在他们的法线方向上挖掘1个单位，也就是+1，（你也可以理解为是挖掘次数）
> 此时 a[0][0]=1, b[0][0]=1, c[0][0]=1;
> 3.然后是第二个挖掘任务，从（1,1,1）挖到（2,2,2）
> 执行操作后， a[1][1]=1, b[1][1]=1, c[1][1]=1;
> 4.后面的操作也是如此，当有一个方向上的法线长度为 N 时，就可以把 1x1xN 的砖放这了

前面说这样的投影有个好处，不用在意他在这条法线的哪里进行挖掘，
因为他要放进去的砖是边长为 N 的，就是一整条直线都得挖干净，
我们利用这种投影方式就像是把这条线上某个点的挖掘平移到一起，
这样挖掘次数就等于挖掘的长度

ps：if 条件里你写 >= 也是一样的，没差
我注释了一个 **if(a[x] [y]== n || b[x] [z]== n || c[y] [z]== n) ans++;**
这样其实是不行的，可能有多个方向满足了条件，但是这么写， ans 就只加了一次
羡慕各位大佬TwT